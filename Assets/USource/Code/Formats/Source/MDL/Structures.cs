using UnityEngine;
using System.Runtime.InteropServices;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using USource.MathLib;

namespace USource.Formats.Source.MDL
{
    [Flags]
    public enum StudioHDRFlags
    {
        // This flag is set if no hitbox information was specified
        STUDIOHDR_FLAGS_AUTOGENERATED_HITBOX = 0x00000001,

        // NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
        // models when we change materials.
        STUDIOHDR_FLAGS_USES_ENV_CUBEMAP = 0x00000002,

        // Use this when there are translucent parts to the model but we're not going to sort it 
        STUDIOHDR_FLAGS_FORCE_OPAQUE = 0x00000004,

        // Use this when we want to render the opaque parts during the opaque pass
        // and the translucent parts during the translucent pass
        STUDIOHDR_FLAGS_TRANSLUCENT_TWOPASS = 0x00000008,

        // This is set any time the .qc files has $staticprop in it
        // Means there's no bones and no transforms
        STUDIOHDR_FLAGS_STATIC_PROP = 0x00000010,

        // NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
        // models when we change materials.
        STUDIOHDR_FLAGS_USES_FB_TEXTURE = 0x00000020,

        // This flag is set by studiomdl.exe if a separate "$shadowlod" entry was present
        //  for the .mdl (the shadow lod is the last entry in the lod list if present)
        STUDIOHDR_FLAGS_HASSHADOWLOD = 0x00000040,

        // NOTE:  This flag is set at loadtime, not mdl build time so that we don't have to rebuild
        // models when we change materials.
        STUDIOHDR_FLAGS_USES_BUMPMAPPING = 0x00000080,

        // NOTE:  This flag is set when we should use the actual materials on the shadow LOD
        // instead of overriding them with the default one (necessary for translucent shadows)
        STUDIOHDR_FLAGS_USE_SHADOWLOD_MATERIALS = 0x00000100,

        // NOTE:  This flag is set when we should use the actual materials on the shadow LOD
        // instead of overriding them with the default one (necessary for translucent shadows)
        STUDIOHDR_FLAGS_OBSOLETE = 0x00000200,

        STUDIOHDR_FLAGS_UNUSED = 0x00000400,

        // NOTE:  This flag is set at mdl build time
        STUDIOHDR_FLAGS_NO_FORCED_FADE = 0x00000800,

        // NOTE:  The npc will lengthen the viseme check to always include two phonemes
        STUDIOHDR_FLAGS_FORCE_PHONEME_CROSSFADE = 0x00001000,

        // This flag is set when the .qc has $constantdirectionallight in it
        // If set, we use constantdirectionallightdot to calculate light intensity
        // rather than the normal directional dot product
        // only valid if STUDIOHDR_FLAGS_STATIC_PROP is also set
        STUDIOHDR_FLAGS_CONSTANT_DIRECTIONAL_LIGHT_DOT = 0x00002000,

        // Flag to mark delta flexes as already converted from disk format to memory format
        STUDIOHDR_FLAGS_FLEXES_CONVERTED = 0x00004000,

        // Indicates the studiomdl was built in preview mode
        STUDIOHDR_FLAGS_BUILT_IN_PREVIEW_MODE = 0x00008000,

        // Ambient boost (runtime flag)
        STUDIOHDR_FLAGS_AMBIENT_BOOST = 0x00010000,

        // Don't cast shadows from this model (useful on first-person models)
        STUDIOHDR_FLAGS_DO_NOT_CAST_SHADOWS = 0x00020000,

        // alpha textures should cast shadows in vrad on this model (ONLY prop_static!)
        STUDIOHDR_FLAGS_CAST_TEXTURE_SHADOWS = 0x00040000,


        // flagged on load to indicate no animation events on this model
        STUDIOHDR_FLAGS_VERT_ANIM_FIXED_POINT_SCALE = 0x00200000,
    }
    public enum ModelFlags
    {
        VTXStripGroupTriListFlag = 0x01,
        VTXStripGroupTriStripFlag = 0x02,
        STUDIO_ANIM_RAWPOS = 0x01,
        STUDIO_ANIM_RAWROT = 0x02,
        STUDIO_ANIM_ANIMPOS = 0x04,
        STUDIO_ANIM_ANIMROT = 0x08,
        STUDIO_ANIM_DELTA = 0x10,
        STUDIO_ANIM_RAWROT2 = 0x20,
    }

    //TODO
    public struct StudioHeader : ISourceObject
    {
        public int id;
        public int version;

        public int checksum;
        public string name;

        public int dataLength;

        public Vector3 eyeposition;
        public Vector3 illumposition;
        public Vector3 hull_min;
        public Vector3 hull_max;
        public Vector3 view_bbmin;
        public Vector3 view_bbmax;

        public StudioHDRFlags flags;

        // mstudiobone_t
        public int bone_count;
        public int bone_offset;

        // mstudiobonecontroller_t
        public int bonecontroller_count;
        public int bonecontroller_offset;

        // mstudiohitboxset_t
        public int hitbox_count;
        public int hitbox_offset;

        // mstudioanimdesc_t
        public int localanim_count;
        public int localanim_offset;

        // mstudioseqdesc_t
        public int localseq_count;
        public int localseq_offset;

        public int activitylistversion;
        public int eventsindexed;

        // mstudiotexture_t
        public int texture_count;
        public int texture_offset;

        public int texturedir_count;
        public int texturedir_offset;

        public int skinreference_count;
        public int skinrfamily_count;
        public int skinreference_index;

        // mstudiobodyparts_t
        public int bodypart_count;
        public int bodypart_offset;

        // mstudioattachment_t
        public int attachment_count;
        public int attachment_offset;

        public int localnode_count;
        public int localnode_index;
        public int localnode_name_index;

        // mstudioflexdesc_t
        public int flexdesc_count;
        public int flexdesc_index;

        // mstudioflexcontroller_t
        public int flexcontroller_count;
        public int flexcontroller_index;

        // mstudioflexrule_t
        public int flexrules_count;
        public int flexrules_index;

        // mstudioikchain_t
        public int ikchain_count;
        public int ikchain_index;

        // mstudiomouth_t
        public int mouths_count;
        public int mouths_index;

        // mstudioposeparamdesc_t
        public int localposeparam_count;
        public int localposeparam_index;

        public int surfaceprop_index;

        public int keyvalue_index;
        public int keyvalue_count;

        // mstudioiklock_t
        public int iklock_count;
        public int iklock_index;

        public float mass;
        public int contents;

        // mstudiomodelgroup_t
        public int includemodel_count;
        public int includemodel_index;

        public int virtualModel;
        // Placeholder for mutable-void*

        // mstudioanimblock_t
        public int animblocks_name_index;
        public int animblocks_count;
        public int animblocks_index;

        public int animblockModel;
        // Placeholder for mutable-void*

        public int bonetablename_index;

        public int vertex_base;
        public int offset_base;

        // Used with $constantdirectionallight from the QC
        // Model should have flag #13 set if enabled
        public byte directionaldotproduct;

        public byte rootLod;
        // Preferred rather than clamped

        // 0 means any allowed, N means Lod 0 -> (N-1)
        public byte numAllowedRootLods;

        public byte unused;
        public int unused2;

        // mstudioflexcontrollerui_t
        public int flexcontrollerui_count;
        public int flexcontrollerui_index;

        public void ReadToObject(UReader reader, int version = 0)
        {
            id = reader.ReadInt32();
            this.version = reader.ReadInt32();
            checksum = reader.ReadInt32();

            name = Converters.IConverter.ByteArrayToString(reader.ReadBytes(64));

            dataLength = reader.ReadInt32();
            eyeposition = reader.ReadVector3();
            illumposition = reader.ReadVector3();
            hull_min = reader.ReadVector3();
            hull_max = reader.ReadVector3();
            view_bbmax = reader.ReadVector3();
            view_bbmax = reader.ReadVector3();
            flags = (StudioHDRFlags)reader.ReadInt32();

            bone_count = reader.ReadInt32();
            bone_offset = reader.ReadInt32();

            bonecontroller_count = reader.ReadInt32();
            bonecontroller_offset = reader.ReadInt32();

            hitbox_count = reader.ReadInt32();
            hitbox_offset = reader.ReadInt32();

            localanim_count = reader.ReadInt32();
            localanim_offset = reader.ReadInt32();

            localseq_count = reader.ReadInt32();
            localseq_offset = reader.ReadInt32();

            activitylistversion = reader.ReadInt32();
            eventsindexed = reader.ReadInt32();

            texture_count = reader.ReadInt32();
            texture_offset = reader.ReadInt32();

            texturedir_count = reader.ReadInt32();
            texturedir_offset = reader.ReadInt32();

            skinreference_count = reader.ReadInt32();
            skinrfamily_count = reader.ReadInt32();
            skinreference_index = reader.ReadInt32();

            bodypart_count = reader.ReadInt32();
            bodypart_offset = reader.ReadInt32();

            attachment_count = reader.ReadInt32();
            attachment_offset = reader.ReadInt32();

            localnode_count = reader.ReadInt32();
            localnode_index = reader.ReadInt32();
            localnode_name_index = reader.ReadInt32();

            flexdesc_count = reader.ReadInt32();
            flexdesc_index = reader.ReadInt32();

            flexcontroller_count = reader.ReadInt32();
            flexcontroller_index = reader.ReadInt32();

            flexrules_count = reader.ReadInt32();
            flexrules_index = reader.ReadInt32();

            ikchain_count = reader.ReadInt32();
            ikchain_index = reader.ReadInt32();

            mouths_count = reader.ReadInt32();
            mouths_index = reader.ReadInt32();

            localposeparam_count = reader.ReadInt32();
            localposeparam_index = reader.ReadInt32();

            surfaceprop_index = reader.ReadInt32();

            keyvalue_index = reader.ReadInt32();
            keyvalue_count = reader.ReadInt32();

            iklock_count = reader.ReadInt32();
            iklock_index = reader.ReadInt32();

            mass = reader.ReadSingle();

            contents = reader.ReadInt32();
            includemodel_count = reader.ReadInt32();
            includemodel_index = reader.ReadInt32();

            virtualModel = reader.ReadInt32();

            animblocks_name_index = reader.ReadInt32();
            animblocks_count = reader.ReadInt32();
            animblocks_index = reader.ReadInt32();

            animblockModel = reader.ReadInt32();

            bonetablename_index = reader.ReadInt32();

            vertex_base = reader.ReadInt32();
            offset_base = reader.ReadInt32();

            directionaldotproduct = reader.ReadByte();
            rootLod = reader.ReadByte();
            numAllowedRootLods = reader.ReadByte();

            reader.Skip(5);  // unknown byte and int

            flexcontrollerui_count = reader.ReadInt32();
            flexcontrollerui_index = reader.ReadInt32();
        }
    }
    public struct StudioBone : ISourceObject
    {
        public int sznameindex;
        public int parent;

        public int[] bonecontroller;  // 6

        public Vector3 pos;
        public Quaternion quat;
        public Vector3 rot;

        public Vector3 posscale;
        public Vector3 rotscale;

        public float[] poseToBone;  // 12

        public Quaternion qAlignment;
        public int flags;
        public int proctype;
        public int procindex;
        public int physicsbone;
        public int surfacepropidx;
        public int contents;

        public int[] unused;  // 8

        public void ReadToObject(UReader reader, int version = 0)
        {
            sznameindex = reader.ReadInt32();
            parent = reader.ReadInt32();

            bonecontroller = reader.ReadIntArray(6);

            pos = reader.ReadVector3();
            quat = reader.ReadQuaternion();
            rot = reader.ReadVector3();

            posscale = reader.ReadVector3();
            rotscale = reader.ReadVector3();

            poseToBone = reader.ReadSingleArray(12);

            qAlignment = reader.ReadQuaternion();
            flags = reader.ReadInt32();
            proctype = reader.ReadInt32();
            procindex = reader.ReadInt32();
            physicsbone = reader.ReadInt32();
            surfacepropidx = reader.ReadInt32();
            contents = reader.ReadInt32();

            reader.Skip(4 * 8);  // unused int array size of 8
        }
    }
    public struct AniInfo
    {
        public string name;
        public StudioAnimDesc studioAnim;
        public List<AnimationBone> AnimationBones;
        public Keyframe[][] PosX;
        public Keyframe[][] PosY;
        public Keyframe[][] PosZ;

        public Keyframe[][] RotX;
        public Keyframe[][] RotY;
        public Keyframe[][] RotZ;
        public Keyframe[][] RotW;
    }
    public class AnimationBone
    {
        public byte Bone;
        public byte Flags;
        public int NumFrames;
        public Quaternion pQuat48;
        public Quaternion pQuat64;
        public Vector3 pVec48;
        public List<Vector3> FrameAngles;
        public List<Vector3> FramePositions;

        public AnimationBone(byte bone, byte flags, int numFrames)
        {
            Bone = bone;
            Flags = flags;
            NumFrames = numFrames;
            FramePositions = new List<Vector3>();
            FrameAngles = new List<Vector3>();
        }

        public void ReadData(UReader br)
        {
            var delta = (Flags & (byte)ModelFlags.STUDIO_ANIM_DELTA) > 0;

            if ((Flags & (byte)ModelFlags.STUDIO_ANIM_ANIMROT) > 0 && NumFrames > 0)
            {
                // Why is this so painful :(
                // Read the per-frame data using RLE, just like GoldSource models
                var startPos = br.BaseStream.Position;
                var offsets = br.ReadShortArray(3);
                var endPos = br.BaseStream.Position;
                var rotFrames = new List<float[]>();
                for (var i = 0; i < NumFrames; i++) rotFrames.Add(new float[] { 0, 0, 0 });
                for (var i = 0; i < 3; i++)
                {
                    if (i < 0 || i >= offsets.Length || offsets[i] == 0) continue;
                    int newPos = ((int)startPos + offsets[i]);
                    if (newPos < 0) continue;
                    br.BaseStream.Position = startPos + offsets[i];
                    var values = br.ReadAnimationFrameValues(NumFrames);
                    for (var f = 0; f < values.Length; f++)
                    {
                        rotFrames[f][i] = +values[f];
                        if (f > 0 && delta) rotFrames[f][i] += values[f - 1];
                    }
                }
                FrameAngles.AddRange(rotFrames.Select(x => new Vector3(x[0], x[1], x[2])));
                br.BaseStream.Position = endPos;
            }
            if ((Flags & (byte)ModelFlags.STUDIO_ANIM_ANIMPOS) > 0 && NumFrames > 0)
            {
                // Same as above, except for the position coordinate
                var startPos = br.BaseStream.Position;
                var offsets = br.ReadShortArray(3);
                var endPos = br.BaseStream.Position;
                var posFrames = new List<float[]>();
                for (var i = 0; i < NumFrames; i++) posFrames.Add(new float[] { 0, 0, 0 });
                for (var i = 0; i < 3; i++)
                {
                    if (offsets[i] == 0) continue;
                    if (startPos + offsets[i] < 0) continue;
                    br.BaseStream.Position = startPos + offsets[i];
                    var values = br.ReadAnimationFrameValues(NumFrames);
                    for (var f = 0; f < values.Length; f++)
                    {
                        posFrames[f][i] = +values[f];
                        if (f > 0 && delta) posFrames[f][i] += values[f - 1];
                    }
                }
                FramePositions.AddRange(posFrames.Select(x => new Vector3(x[0], x[1], x[2])));
                br.BaseStream.Position = endPos;
            }
            if ((Flags & (byte)ModelFlags.STUDIO_ANIM_RAWROT) > 0)
            {
                var quat48 = new Quaternion48();
                quat48.theXInput = br.ReadUInt16();
                quat48.theYInput = br.ReadUInt16();
                quat48.theZWInput = br.ReadUInt16();

                this.pQuat48 = quat48.quaternion;
            }
            if ((Flags & (byte)ModelFlags.STUDIO_ANIM_RAWROT2) > 0)
            {
                var quat64 = new Quaternion64();
                quat64.theBytes = br.ReadBytes(8);

                this.pQuat64 = quat64.quaternion;
            }
            if ((Flags & (byte)ModelFlags.STUDIO_ANIM_RAWPOS) > 0)
            {
                var vec48 = new Vector48();
                vec48.x = new Float16 { bits = br.ReadUInt16() };
                vec48.y = new Float16 { bits = br.ReadUInt16() };
                vec48.z = new Float16 { bits = br.ReadUInt16() };

                this.pVec48 = vec48.ToVector3();
            }
        }
    }
    public struct SeqInfo
    {
        public string name;
        public StudioSeqDesc seq;
        public AniInfo ani;
    }
    public struct StudioAnimDesc : ISourceObject
    {
        public int baseptr;
        public int sznameindex;

        public float fps;      // frames per second	
        public int flags;     // looping/non-looping flags

        public int numframes;

        // piecewise movement
        public int nummovements;
        public int movementindex;

        public int[] unused1;         // remove as appropriate (and zero if loading older versions)	

        public int animblock;
        public int animindex;  // non-zero when anim data isn't in sections

        public int numikrules;
        public int ikruleindex;   // non-zero when IK data is stored in the mdl
        public int animblockikruleindex; // non-zero when IK data is stored in animblock file

        public int numlocalhierarchy;
        public int localhierarchyindex;

        public int sectionindex;
        public int sectionframes; // number of frames used in each fast lookup section, zero if not used

        public short zeroframespan; // frames per span
        public short zeroframecount; // number of spans
        public int zeroframeindex;
        public float zeroframestalltime;       // saved during read stalls

        public void ReadToObject(UReader reader, int version = 0)
        {
            baseptr = reader.ReadInt32();
            sznameindex = reader.ReadInt32();
            fps = reader.ReadSingle();
            flags = reader.ReadInt32();
            numframes = reader.ReadInt32();
            nummovements = reader.ReadInt32();
            movementindex = reader.ReadInt32();

            reader.Skip(4 * 6);  // unused int array size 6

            animblock = reader.ReadInt32();
            animindex = reader.ReadInt32();

            numikrules = reader.ReadInt32();
            ikruleindex = reader.ReadInt32();
            animblockikruleindex = reader.ReadInt32();

            numlocalhierarchy = reader.ReadInt32();
            localhierarchyindex = reader.ReadInt32();

            sectionindex = reader.ReadInt32();
            sectionframes = reader.ReadInt32();

            zeroframespan = reader.ReadInt16();
            zeroframecount = reader.ReadInt16();
            zeroframeindex = reader.ReadInt32();
            zeroframestalltime = reader.ReadSingle();
        }
    }
    public struct StudioSeqDesc : ISourceObject
    {
        public int baseptr;

        public int szlabelindex;

        public int szactivitynameindex;

        public int flags;     // looping/non-looping flags

        public int activity;  // initialized at loadtime to game DLL values
        public int actweight;

        public int numevents;
        public int eventindex;

        public Vector3 bbmin;       // per sequence bounding box
        public Vector3 bbmax;

        public int numblends;

        // Index into array of shorts which is groupsize[0] x groupsize[1] in length
        public int animindexindex;

        public int movementindex; // [blend] float array for blended movement
        public int[] groupsize;
        public int[] paramindex;  // X, Y, Z, XR, YR, ZR
        public float[] paramstart; // local (0..1) starting value
        public float[] paramend;   // local (0..1) ending value
        public int paramparent;

        public float fadeintime;       // ideal cross fate in time (0.2 default)
        public float fadeouttime;  // ideal cross fade out time (0.2 default)

        public int localentrynode;        // transition node at entry
        public int localexitnode;     // transition node at exit
        public int nodeflags;     // transition rules

        public float entryphase;       // used to match entry gait
        public float exitphase;        // used to match exit gait

        public float lastframe;        // frame that should generation EndOfSequence

        public int nextseq;       // auto advancing sequences
        public int pose;          // index of delta animation between end and nextseq

        public int numikrules;

        public int numautolayers; //
        public int autolayerindex;

        public int weightlistindex;

        // FIXME: make this 2D instead of 2x1D arrays
        public int posekeyindex;

        public int numiklocks;
        public int iklockindex;

        // Key values
        public int keyvalueindex;
        public int keyvaluesize;

        public int cycleposeindex;        // index of pose parameter to use as cycle index

        public int activitymodifierindex;
        public int numactivitymodifiers;
        public void ReadToObject(UReader reader, int version = 0)
        {
            baseptr = reader.ReadInt32();
            szlabelindex = reader.ReadInt32();
            szactivitynameindex = reader.ReadInt32();
            flags = reader.ReadInt32();
            activity = reader.ReadInt32();
            actweight = reader.ReadInt32();
            numevents = reader.ReadInt32();
            eventindex = reader.ReadInt32();
            bbmin = reader.ReadVector3();
            bbmax = reader.ReadVector3();
            numblends = reader.ReadInt32();
            animindexindex = reader.ReadInt32();
            movementindex = reader.ReadInt32();
            groupsize = reader.ReadIntArray(2);
            paramindex = reader.ReadIntArray(2);
            paramstart = reader.ReadSingleArray(2);
            paramend = reader.ReadSingleArray(2);
            paramparent = reader.ReadInt32();
            fadeintime = reader.ReadSingle();
            fadeouttime = reader.ReadSingle();
            localentrynode = reader.ReadInt32();
            localexitnode = reader.ReadInt32();
            nodeflags = reader.ReadInt32();
            entryphase = reader.ReadSingle();
            exitphase = reader.ReadSingle();
            lastframe = reader.ReadSingle();
            nextseq = reader.ReadInt32();
            pose = reader.ReadInt32();
            numikrules = reader.ReadInt32();
            numautolayers = reader.ReadInt32();
            autolayerindex = reader.ReadInt32();
            weightlistindex = reader.ReadInt32();
            numiklocks = reader.ReadInt32();
            iklockindex = reader.ReadInt32();
            keyvalueindex = reader.ReadInt32();
            keyvaluesize = reader.ReadInt32();
            cycleposeindex = reader.ReadInt32();
            activitymodifierindex = reader.ReadInt32();
            numactivitymodifiers = reader.ReadInt32();
            reader.Skip(4 * 5);  // unused int array of size 5

        }
    }        //SEQUENCE
    public struct StudioBBox : ISourceObject
    {
        public int bone;
        public int group;                 // intersection group
        public Vector3 bbmin;              // bounding box
        public Vector3 bbmax;
        public int szhitboxnameindex;  // offset to the name of the hitbox.
        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 8)]
        public int[] unused;

        public void ReadToObject(UReader reader, int version = 0)
        {
            bone = reader.ReadInt32();
            group = reader.ReadInt32();
            bbmin = reader.ReadVector3();
            bbmax = reader.ReadVector3();
            szhitboxnameindex = reader.ReadInt32();
            reader.Skip(4 * 8);  // unused int array of size 8
        }
    }
    public struct Hitbox
    {
        public string Name;
        public StudioBBox BBox;
    }
    public struct StudioHitboxSet : ISourceObject
    {
        public int sznameindex;
        public int numhitboxes;
        public int hitboxindex;
        public void ReadToObject(UReader reader, int version = 0)
        {
            sznameindex = reader.ReadInt32();
            numhitboxes = reader.ReadInt32();
            hitboxindex = reader.ReadInt32();
        }
    }
    public struct StudioTexture : ISourceObject
    {
        public int sznameindex;
        public int flags;
        public int used;
        public int unused1;
        public int material;
        public int clientmaterial;

        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 10)]
        public int[] unused;

        public void ReadToObject(UReader reader, int version = 0)
        {
            sznameindex = reader.ReadInt32();
            flags = reader.ReadInt32();
            used = reader.ReadInt32();
            reader.Skip(4);  // unused int
            material = reader.ReadInt32();
            clientmaterial = reader.ReadInt32();
            reader.Skip(4 * 10);  // unused int array of size 10
        }
    }
    public struct StudioBodyPart
    {
        public string Name;
        public Model[] Models;
    }
    public struct Model
    {
        public bool isBlank;
        public StudioModel model;
        public mstudiomesh_t[] Meshes;
        public Dictionary<int, List<int>>[] IndicesPerLod;
        public StudioVertex[][] VerticesPerLod;
    }
    public struct StudioBodyParts : ISourceObject
    {
        public int sznameindex;
        public int nummodels;
        public int _base;
        public int modelindex;
        public void ReadToObject(UReader reader, int version = 0)
        {
            sznameindex = reader.ReadInt32();
            nummodels = reader.ReadInt32();
            _base = reader.ReadInt32();
            modelindex = reader.ReadInt32();
        }
    }
    public struct StudioModel : ISourceObject
    {
        public string name;

        public int type;
        public float boundingradius;
        public int nummeshes;
        public int meshindex;

        public int numvertices;
        public int vertexindex;
        public int tangentsindex;

        public int numattachments;
        public int attachmentindex;

        public int numeyeballs;
        public int eyeballindex;

        public StudioModelVertexData vertexdata;
        public void ReadToObject(UReader reader, int version = 0)
        {
            name = Converters.IConverter.ByteArrayToString(reader.ReadBytes(64));
            type = reader.ReadInt32();
            boundingradius = reader.ReadSingle();
            nummeshes = reader.ReadInt32();
            meshindex = reader.ReadInt32();

            numvertices = reader.ReadInt32();
            vertexindex = reader.ReadInt32();
            tangentsindex = reader.ReadInt32();

            numattachments = reader.ReadInt32();
            attachmentindex = reader.ReadInt32();

            numeyeballs = reader.ReadInt32();
            eyeballindex = reader.ReadInt32();

            vertexdata = reader.ReadSourceObject<StudioModelVertexData>(version);

            reader.Skip(4 * 8);  // unused int32 array of size 8
        }
    }
    public struct StudioModelVertexData : ISourceObject
    {
        public int vertexData;
        public int tangentData;

        public void ReadToObject(UReader reader, int version = 0)
        {
            version = reader.ReadInt32();
            vertexData = reader.ReadInt32();
        }
    }
    public struct StudioAttachment : ISourceObject
    {
        public int sznameindex;
        public ushort flags;
        public int localbone;
        public Matrix4x4 local;
        public void ReadToObject(UReader reader, int version = 0)
        {
            sznameindex = reader.ReadInt32();
            flags = reader.ReadUInt16();
            localbone = reader.ReadInt32();

            local = new Matrix4x4();
            local.SetRow(0, reader.ReadVector3());
            local.SetRow(1, reader.ReadVector3());
            local.SetRow(2, reader.ReadVector3());
            local.SetRow(3, reader.ReadVector3());

            reader.Skip(4 * 8);  // unused int32 array of size 8
        }
    }
    public struct mstudiomesh_t : ISourceObject
    {
        public int material;
        public int modelindex;
        public int numvertices;
        public int vertexoffset;
        public int numflexes;
        public int flexindex;
        public int materialtype;
        public int materialparam;
        public int meshid;
        public Vector3 center;
        public StudioMeshVertexData VertexData;

        public void ReadToObject(UReader reader, int version = 0)
        {
            material = reader.ReadInt32();
            modelindex = reader.ReadInt32();
            numvertices = reader.ReadInt32();
            vertexoffset = reader.ReadInt32();
            numflexes = reader.ReadInt32();
            flexindex = reader.ReadInt32();
            materialtype = reader.ReadInt32();
            materialparam = reader.ReadInt32();
            meshid = reader.ReadInt32();
            center = reader.ReadVector3();
            VertexData = reader.ReadSourceObject<StudioMeshVertexData>(version);
            reader.Skip(4 * 8);  // unused int32 array of size 8
        }
    }
    public struct StudioMeshVertexData : ISourceObject
    {
        public int modelvertexdata;
        public int[] numlodvertices;
        public void ReadToObject(UReader reader, int version = 0)
        {
            modelvertexdata = reader.ReadInt32();
            numlodvertices = reader.ReadIntArray(8);
        }
    }
    public struct StudioVertex : ISourceObject
    {
        public StudioBoneWeight m_BoneWeights;
        public Vector3 m_vecPosition;
        public Vector3 m_vecNormal;
        public Vector2 m_vecTexCoord;

        public void ReadToObject(UReader reader, int version = 0)
        {
            m_BoneWeights = reader.ReadSourceObject<StudioBoneWeight>();
            m_vecPosition = Converters.IConverter.SourceTransformPoint(reader.ReadVector3());
            m_vecNormal = Converters.IConverter.SourceTransformDirection(reader.ReadVector3());
            m_vecTexCoord = reader.ReadVector2();
            m_vecTexCoord.y *= -1;
            m_vecTexCoord.y += 1;
        }
    }
    public struct StudioBoneWeight : ISourceObject
    {
        public Vector3 weight;
        public byte[] bone;
        public byte numbones;

        public void ReadToObject(UReader reader, int version = 0)
        {
            weight = reader.ReadVector3();
            bone = reader.ReadBytes(3);
            numbones = reader.ReadByte();
        }
    }
}
